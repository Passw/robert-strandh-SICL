\chapter{Processing return values}

Multiple values can be produced only as a result of a function call.
With the default calling convention, a stack frame consists of:

\begin{itemize}
\item the frame pointer of the caller,
\item the call-site descriptor,
\item the return address (if saved), and
\item lexical variables required to accomplish the task.
\end{itemize}

The caller creates this stack frame for the callee.  Information about
the amount of space required for lexical variables is stored in the
function object, and accessed by the caller.

With the default calling convention, the caller stores the arguments
on top of the callee stack frame in reverse order.  The initial task
of the callee is then to parse the arguments and store the result in
lexical variables, either in registers or in the stack frame.  The
callee then removes the arguments from the stack.

When the callee returns, its stack frame is replaced by the return
values in reverse order.  The frame pointer of the caller has been
store in a register so that the caller can access it and restore its
frame pointer.

The following operators consume multiple values:

\begin{itemize}
\item \texttt{multiple-value-call}
\item \texttt{multiple-value-bind}
\item \texttt{multiple-value-setq}
\item \texttt{multiple-value-list}
\item \texttt{setf} with \texttt{values}
\end{itemize}

\section{\texttt{multiple-value-call}}

This operator can be seen as the most basic consumer of multiple
values.

\section{\texttt{multiple-value-bind}}

The standard says that

\begin{verbatim}
(multiple-value-bind ({var}*) values-form {form}*)
\end{verbatim}

is equivalent to

\begin{verbatim}
(multiple-value-call
    (lambda (&optional {var}* &rest #1=:ignore)
      (declare (ignore #1#))
      {form}*)
  values-form)
\end{verbatim}

Provided that a \texttt{\&rest} variable that is unused in the
function body is handled by not allocating a list of the remaining
arguments, this definition is not too bad.  Clearly,
\texttt{multiple-value-bind} must check the number of arguments, and
initialize optional parameters with \texttt{nil} when a corresponding
argument is omitted.  This is the same work as the anonymous function
in the second code snippet does.

\section{\texttt{multiple-value-setq}}

The standard says that

\begin{verbatim}
(multiple-value-setq ({symbol}*) values-form)
\end{verbatim}

Is defined to behave the same way as

\begin{verbatim}
(values (setf (values {symbol}*) values-form))
\end{verbatim}

where the outermost \texttt{values} is there to make sure that a
single value is returned, as the standard requires. 

\section{\texttt{multiple-value-list}}

The standard says that

\begin{verbatim}
(multiple-value-list values-form)
\end{verbatim}

is equivalent to

\begin{verbatim}
(multiple-value-call #'list values-form)
\end{verbatim}

It is very likely that allocating the \texttt{cons} cells that make up
the list will dominate over the use of the default calling convention,
so this equivalent form can be used without optimization. 

\section{\texttt{setf} with \texttt{values}}

According to the standard, \texttt{setf} with \texttt{values} binds
the variables ``as if by \texttt{multiple-value-bind}'', and this is
also a reasonable implementation.  Since \texttt{multiple-value-bind}
is defined in terms of \texttt{multiple-value-call}.  Therefore, all
operators that consume multiple values can be reduced to
\texttt{multiple-value-call}.

% LocalWords:  callee
