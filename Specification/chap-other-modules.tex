\chapter{Other portable modules}

\section{Concrete syntax tree}
\label{sec-concrete-syntax-tree}

The Concrete Syntax Tree%
\footnote{https://github.com/s-expressionists/Concrete-Syntax-Tree}
module was designed to solve the problem of \emph{source tracking},
i.e., the association of some source code with some concept of
\emph{location} of that code in a source file.

This module handles the problem by wrapping S-expressions in standard
objects that can contain this additional information.  The standard
object in question mimics two kinds of S-expressions, namely
\texttt{cons} cells and \emph{atoms}.  Operations are provided by this
module to take the \texttt{first} and the \texttt{rest} of a standard
object that representes a \texttt{cons} cell, and to return the
\emph{raw} contents of a concrete syntax tree, i.e., the underlying
S-expression.

Furthermore, this module provides a certain number of higher-level
utilities for manipulating concrete syntax trees.  For example, it
contains a lambda-list parser for lambda lists that are represented as
concrete syntax trees.

A particularly important utility is one that \emph{reconstructs} a
concrete syntax tree from two arguments, namely a concrete syntax tree
and an S-expression.  This utility can be used in a compiler for macro
expansion.  \commonlisp{} macro expansion is specified to work on
S-expressions.  The problem, then, is to preserve source information
across macro expansion.  A compiler would then take a concrete syntax
tree, retrieve the raw underlying S-expression and pass that
S-expression to the macro function.  The macro function returns
another S-expression that typically contains some nodes of the
original S-expression and some nodes that were introduced by the macro
function.  The reconstruction utility tries to match nodes in the
output to nodes in the input, and construct a concrete syntax tree
from the result.  For \texttt{cons} cells, the task is fairly simple.
If the \emph{same} (as determined by \texttt{eq}) \texttt{cons} cell
exists in the input and in the output, the concrete syntax tree for
that \texttt{cons} cell in the input is reused in the reconstructed
concrete syntax tree.  For atoms, the problem is harder.  The concrete
syntax tree module uses some heuristics to provide a plausible
reconstruction.

The concrete syntax tree module also contains a parser for lambda
lists, represented as concrete syntax trees.  This parser uses the
Earley parsing technique, which we believe is a good fit for parsing
S-expressions.  However, the way the parser is expressed is currently
not satisfactory.  We are looking for alternative ways of expressing
parsers on S-expressions.

\section{First-class global environments}
\label{sec-first-class-global-environments}

Most \commonlisp{} implementations do not have an explicit
(first-class) representation for the global environments, and most
\commonlisp{} implementations have a single global environment.  This
environment is \emph{spread out} all over the system.  The
\texttt{symbol} objects of such an implementation may contain a slot
for a function named by that symbol and perhaps a slot for the global
value of a variable named by that symbol.  The mapping from class
names to class objects can also be represented as a slot in the symbol
object, but is more likely represented separately in a hash table.
Similarly, method combinations, \texttt{setf} expanders, and other
mappings from names to objects may be represented in yet another way.

\sysname{} uses \emph{first-class global environments} for all these
mappings.  There are several reasons for this way of representing
environments:

\begin{itemize}
\item It allows for multiple global environments, which in turn
  provides solutions to a number of common problems.  For example,
  several different versions of a system can be loaded simultaneously,
  provided that each version is loaded into a separate environment.
\item It becomes possible (and easy) to distinguish the three types of
  global environments that the \commonlisp{} standard allows (and
  sometimes encourages), namely run-time environments, evaluation
  environments, and compilation environments.
\item During bootstrapping of \sysname{} using a \emph{host}
  \commonlisp{} system, \sysname{} objects and mappings can be
  isolated from host objects and mappings by the use of first-class
  environments.
\end{itemize}

First-class environments also allow for other features such as
\emph{sandboxing} that are not directly used by \sysname{}.

This module has been extracted to a separate repository by the name of
\clostrum{}%
\footnote{https://github.com/s-expressionists/Clostrum} and it
provides several important features:

\begin{itemize}
\item The run-time environment is operated upon by a number of generic
  functions that mimic standard \commonlisp{} functions such as
  \texttt{fdefinition}, \texttt{macro-function}, etc., except that
  these functions have an additional parameter named \emph{client}.
  Client code can provide primary or auxiliary methods that specialize
  to some client-provided class, so as to override or extend the
  behavior of the default methods provided by \clostrum{}.
\item The evaluation environment is similar to the run-time
  environment, but also provides trampoline methods that calls the
  same generic function in the run-time environment whenever some
  object is not found in the evaluation environment.
\item The compilation environment is different, and can be used to
  hold imple\-mentation-specific information provided by the compiler
  during the compilation process, and queried by other parts of the
  compiler so as to provide feedback to the user in the form of errors
  or warnings.
\end{itemize}

Furthermore, \clostrum{} environments can be configured in multiple
\emph{layers}, so as to allow for \emph{incremental deltas}.  This
feature could be used in a text editor for parsing the contents of a
text buffer containing \commonlisp{} code.  When the buffer contents
is modified, side effects on the global environment by the old
contents can be undone by simply abandoning the upper layers while
preserving the environment contents associated with the code preceding
the modification.
