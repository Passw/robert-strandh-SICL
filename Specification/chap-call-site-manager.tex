\chapter{Call-site manager}
\label{chap-call-site-manager}

The contents of this chapter is a summary and an update of the paper
we published in ELS 2021 \cite{DBLP:conf/els/Strandh21}.

In the most general case, an external function is called approximately
like this:
\begin{enumerate}
\item Compute the callee and the arguments into temporary locations.
\item Remember the value of the stack pointer in a lexical variable.
\item Push the frame pointer onto the stack.
\item Load the rack of the callee into a free register.
\item Load the static environment from the rack into a dedicated
  register.
\item Load the initial frame size of the callee into a free register.
\item Load the entry point from the rack to a free register.
\item Subtract the initial frame size of the callee from the stack
  pointer.
\item Push the arguments onto the stack.
\item Load the dynamic environment into a dedicated register.
\item Store the remembered value of the stack pointer (minus 1) into
  the frame pointer, thereby establishing an initial frame for the
  callee.
\item Execute an instruction such as \texttt{call}.
\end{enumerate}

As we can see, all arguments are passed on the stack, which is
obviously not optimal.  The initial frame of the callee is what the
callee needs in order to parse the arguments into its own lexical
variables.  Parsing the arguments is done by a part of the function
called the \emph{prelude}.

When the callee is about to return to the caller, it follows the
following approximate steps:

\begin{enumerate}
\item Compute the return values into temporary locations.
\item Remember the contents of the stack at the frame-pointer
  location, which is the frame pointer of the caller.
\item Store the values onto the stack, starting with the first values
  overwriting the caller frame pointer.
\item In a dedicated register, store the first return value, or
  \texttt{nil} if there are no return values.
\item Execute an instruction such as \texttt{return}.
\end{enumerate}

The values returned by the callee are now on top of the stack, between
the remembered value of the stack pointer and the real stack pointer,
so that they are part of the stack frame of the caller.  Again, all
values are on the stack, and the number of values must be determined
by subtracting the remembered value of the stack pointer and the real
stack pointer.  The only exception is when the caller needs exactly
one return value, in which case, it can access the dedicated register.

If the call site consists of the name of a function followed by forms
that compute the arguments, then the function call described above is
not executed directly in the caller.  Instead, the call site consists
of a single unconditional \texttt{jump} instruction.  The target of
this instruction is called a \emph{trampoline snippet} or just a
\emph{snippet} for short.  The call-site manager allocates a new
snippet when required, and alters the target of the \texttt{jump}
instruction.  For a general call, the snippet contains the
instructions described above, and those are generated by the call-site
manager.  The last instruction of the snippet is another unconditional
\texttt{jump} instruction that jumps back to the instruction following
the first \texttt{jump} instruction.

The snippet is recomputed whenever the callee is updated, such as when
a call to \texttt{(setf fdefinition)} is made.  The snippet is thus
customized for the callee in the following ways:

\begin{enumerate}
\item The static environment is a constant and does not have to be
  loaded from the rack.  If the callee does not close over any
  variables, the static environment does not have to be accessed at
  all.
\item The initial frame size of the callee is a constant and does not
  have to be loaded from the rack
\item The entry point is a constant and does not have to be loaded
  from the rack.
\end{enumerate}

Already, these constants save many memory operations, thereby making
the call more efficient.  However, the prelude of a function is
followed by a \emph{general body} of the function, and that body
contains instructions for communicating with the debugger as describe
in \refChap{chap-debugger}.  So the call-site manager uses the entry
point of the prelude only when a breakpoint has been set in the
callee.

The compiler generates an optimized function body to be used when
there are no breakpoints.  This optimized function body is not
preceded by a prelude for parsing arguments.  Instead, the call-site
manager uses information provided in the callee to access arguments in
the caller and put them in the locations expected by the optimized
function body.  Thus, there is no argument parsing performed by the
callee, which is particularly advantageous when the callee has
optional and/or keyword parameters and the call-site provides those
arguments in the most common way.%
\footnote{So that keyword arguments are pairs, each one of which is a
  symbol in the \texttt{keyword} package followed by a value.}
In that case, the call-site manager generates code to access the
relevant argument directly and put it directly where the optimize
function body of the callee expects it.

Further optimizations are possible when the callee is \emph{values
  consistent}, meaning that it always returns the same number of
values.  Then the call-site manager can directly access the return
values from the lexical locations in the callee and put them in
locations expected by the caller.

Initial versions of \sysname{} will not include a call-site manager.
Each call site will contain the general call sequence described
above.

% LocalWords:  callee
