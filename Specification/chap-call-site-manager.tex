\chapter{Call-site manager}
\label{chap-call-site-manager}

The contents of this chapter is a summary and an update of the paper
we published in ELS 2021 \cite{DBLP:conf/els/Strandh21}.

The default calling conventions are described in
\refChap{chap-calling-conventions}.  In summary:

\begin{itemize}
\item we do not use callee-saves registers,
\item the caller sets up the stack frame for the callee,
\item all arguments are passed on the stack on top of the callee stack
  frame, and
\item return values beyond the first one are returned on the stack.
\end{itemize}

Parsing the arguments is done by a part of the callee function
called the \emph{prelude}.  The result of this action is to initialize
lambda-list parameters stored either in registers or in the stack
frame.  The last action of the prelude is to remove the arguments from
the stack.

If the call site consists of the name of a function followed by forms
that compute the arguments, then the code for the default calling
conventions is not directly present in the caller.  Instead, the call
site consists of a single unconditional \texttt{jump} instruction.
The target of this instruction is called a \emph{trampoline snippet}
or just a \emph{snippet} for short.  The call-site manager allocates a
new snippet when required, and alters the target of the \texttt{jump}
instruction.  For a general call, the snippet contains the
instructions of the default calling conventions, and those are
generated by the call-site manager.  The last instruction of the
snippet is another unconditional \texttt{jump} instruction that jumps
back to the instruction following the first \texttt{jump} instruction.

The snippet is recomputed whenever the callee is updated, such as when
a call to \texttt{(setf fdefinition)} is made.  The snippet is thus
customized for the callee in the following ways:

\begin{enumerate}
\item The static environment is a constant and does not have to be
  loaded from the rack.  If the callee does not close over any
  variables, the static environment does not have to be accessed at
  all.
\item The frame size of the callee is a constant and does not
  have to be loaded from the rack
\item The entry point is a constant and does not have to be loaded
  from the rack.
\end{enumerate}

Already, these constants save many memory operations, thereby making
the call more efficient.  However, the prelude of a function is
followed by a \emph{general body} of the function, and that body
contains instructions for communicating with the debugger as describe
in \refChap{chap-debugger}.  So the call-site manager uses the entry
point of the prelude only when a breakpoint has been set in the
callee.

The compiler generates an optimized function body to be used when
there are no breakpoints.  This optimized function body is not
preceded by a prelude for parsing arguments.  Instead, the call-site
manager uses information provided in the callee to access arguments in
the caller and put them in the locations expected by the optimized
function body.  Thus, there is no argument parsing performed by the
callee, which is particularly advantageous when the callee has
optional and/or keyword parameters and the call-site provides those
arguments in the most common way.%
\footnote{So that keyword arguments are pairs, each one of which is a
  symbol in the \texttt{keyword} package followed by a value.}
In that case, the call-site manager generates code to access the
relevant argument directly and put it directly where the optimized
function body of the callee expects it.

When a function is redefined, first every trampoline snippet that calls
that function is updated so that it uses the default argument-parsing
entry point of the function.  This entry point is always valid in each
function, so redefining the function will cause no problem.  After the
function has been updated, each of these trampoline snippets is again
updated according to the optimized entry point of the new function.

Section 3.2.2.3 of the \commonlisp{} standard says: ``Within a
function named F, the compiler may (but is not required to) assume
that an apparent recursive call to a function named F refers to the
same definition of F, unless that function has been declared
notinline. The consequences of redefining such a recursively defined
function F while it is executing are undefined.''%
\footnote{For one thing it is not clear what ``a function named F''
  means, since functions do not have names.  And in general, the
  compiler does not have any knowledge about any name when a lambda
  expression is turned into a function.  Furthermore, if a form such
  as \texttt{(progn (setf (fdefinition 'G) (fdefinition 'F))
    (fmakunbound 'F))} is evaluated, does that mean that the name of
  the function is now \texttt{G}?}
We do not intend to take advantage of this possibility given by the
standard, simply because the call-site manager will make the call very
efficient whatever function it refers to.  Furthermore, the call-site
manager will be able to turn a tail-recursive call into the equivalent
of a loop.

Initial versions of \sysname{} will not include a call-site manager.
Each call site will contain the general call sequence described
above.

\section{Unfinished suggestion of further optimizations}

This section contains a fairly radical suggestion for further
optimizations that involve the call-site manager.

\begin{itemize}
\item Registers that need to be preserved across a function call are
  not saved by the caller itself.  Instead, this becomes the
  responsibility of the trampoline snippet created by the call-site
  manager.  The call-site contains a list of pairs, each consisting of
  a register and a stack location, where the register is one that
  needs to be preserved and the stack location is where the register
  should be stored, should storing be required.  In the most general
  case, the call-site manager creates a trampoline snippet that stores
  each registers in the list in its stack location before calling the
  callee, and restores the register after the callee returns.
\item Each function contains a set (represented as a bitmap) of the
  registers it itself uses, and the registers used by all of its
  callees.  This information is basically the union of the similar
  information of all its callees, and the set of registers the
  function itself uses.
\item For a given pair of a caller and a callee, the trampoline
  snippet needs to save and restore a caller register that must be
  preserved across the call only if that register is used by the
  callee, directly or indirectly, as indicated by the bitmap of the
  callee.
\item When the compiler generates code for a function, the register
  allocator chooses registers randomly, rather than systematically in
  some (perhaps numerical) order.  This way, the likelihood that a
  register that is used by a caller is also used by its callee is
  lowered.
\end{itemize}

We believe that this technique will avoid many register spills across
calls, and therefore it will save many memory accesses.

The main difficulty of this suggestion is what happens when a function
is redefined, especially if one of its callers is already on the
invocation stack.  The new definition will use a different set of
registers than the old definition, and it becomes very possible that
one such register is also used by a caller, and that this register was
not saved by the trampoline snippet.

At the very least, the stack would have to be traversed, and registers
would have to be saved to stack locations, according to the set of
pairs of register and stack location of each call site.  But the
trampoline snippet does not contain code for reloading such registers
after the callee returns, so a new snippet would also have to be
created.  It would even be possible to save every register in the list
of pairs and create code in the snippet for restoring every such
register.  Doing so would not be optimal, but no worse than the
default.

Another (minor) difficulty is the stack-scanning part of the garbage
collector.  It would have to scan the stack from bottom to top in
order to determine which registers are live (and contain \commonlisp{}
objects) to trace.

% LocalWords:  callee callees allocator
