(cl:in-package #:cleavir-cst-to-ast)

;;; VAR is a LEXICAL-VARIABLE that will be set by the implementation-
;;; specific argument-parsing code, according to what arguments were
;;; given. SUPPLIED-P-AST is similarly the value of the supplied-p
;;; variable. VALUE-AST is an AST that computes the initialization
;;; for the variable to be used when no explicit value is supplied by
;;; the caller.  This function generates the code for testing whether
;;; SUPPLIED-P-AST computes NIL or T, and for assigning the value
;;; computed by VALUE-AST to VAR if SUPPLIED-P-AST computes NIL.
(defun make-initialization-ast
    (var-cst var supplied-p-ast value-ast origin env system)
  (let ((nil-cst (make-atom-cst nil origin)))
    (cleavir-ast:make-if-ast
     (cleavir-ast:make-eq-ast
      supplied-p-ast
      (convert-constant nil-cst env system)
      :origin origin)
     (cleavir-ast:make-setq-ast var value-ast :origin origin)
     (convert-constant nil-cst env system)
     :origin origin)))

;;; VAR-CST and SUPPLIED-P-CST are CSTs representing a parameter
;;; variable and its associated SUPPLIED-P variable. If no associated
;;; SUPPLIED-P variable is present in the lambda list then
;;; SUPPLIED-P-CST is NIL.  INIT-AST is the AST that computes the
;;; value to be assigned to the variable represented by VAR-CST if no
;;; argument was supplied for it.  ENV is an environment that already
;;; contains the variables corresponding to VAR-CST and SUPPLIED-P-CST
;;; (if it is not NIL).
;;;
;;; This function returns two values.  The first value is an AST that
;;; represents both the processing of this parameter AND the
;;; computation that follows.  We can not return an AST only for this
;;; computation, because if either one of the variables represented by
;;; VAR-CST or SUPPLIED-P-CST is special, then NEXT-AST must be in the
;;; body of a BIND-AST generated by this function.  The second return
;;; value is a list of two LEXICAL-ASTs.  The first lexical AST
;;; corresponds to VAR-CST and the second to SUPPLIED-P-CST.  The
;;; implementation-specific argument-parsing code is responsible for
;;; assigning to those LEXICAL-ASTs according to what arguments were
;;; given to the function.
(defun process-init-parameter
    (var-cst var supplied-p-cst supplied-p-var init-ast env next-thunk system)
  (let ((origin (cst:source var-cst)))
    (process-progn
     (list (make-initialization-ast var-cst var
                                    (cleavir-ast:make-lexical-ast
                                     supplied-p-var)
                                    init-ast
                                    origin env system)
           (set-or-bind-variable
            var-cst (cleavir-ast:make-lexical-ast var)
            (if (null supplied-p-cst)
                next-thunk
                (lambda ()
                  (set-or-bind-variable
                   supplied-p-cst
                   (cleavir-ast:make-lexical-ast
                    supplied-p-var
                    :origin (cst:source supplied-p-cst))
                   next-thunk env system)))
            env system))
     origin)))
